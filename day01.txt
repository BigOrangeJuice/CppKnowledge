C++_day01
2021/10/20

1.引用

	* 基本语法：数据类型 &别名 = 变量名 ;

	* 作用：通过别名与原变量之间建立链接，指向同一块空间，对别名进行操作也可以影响到原变量

	* 注意：

		—— 引用必须初始化

		—— 引用一旦初始化，不可再更改 ;【类似于常量指针，指向不可变】

	* 另外，可以通过引用给其他变量赋值【本质就是拿着原变量的数据拷贝了一份给了新变量】，但通过修改新变量并不会影响到原变量

	* 引用做函数参数：简化地址传递

	* 引用做函数返回值：

		—— 不要返回局部变量的引用

			* 可以通过static修饰成为静态变量来延长生命周期

		—— 函数的调用可以作为左值

			* 基本语法：函数名() = 数据 ;

			* 作用：子函数内的被引用变量所存放的数据被更改

	* 常量引用：

		—— 基本语法：const 数据类型& 别名 (= 字面值/变量名) ;

		—— 作用：通常用于修饰形参，防止参数被误操作

2.封装

	* 作用：将各种数据类型的变量封存在一起，成为一个整体的对象

	* 访问权限：		类内		类外		继承

		public：	可访问		可访问		自由访问

		protected：	可访问		不可访问	子类仍可访问	

		private：	可访问		不可访问	子类不可访问

	* class与struct的区别：

		—— class默认权限是private，struct默认权限是public

		—— C++中，struct里也可以拥有函数，但一旦struct只用于存放数据变量

3.构造函数和析构函数

	* 构造函数

		—— 基本语法：类名(){}

		—— 注意：

			* 无返回值也不写void【这里的无返回值只是单纯的无需手写返回值】

			* 函数名必须与类名相同

			* 构造函数也可有形参【因此可以发生重载】

			* 程序在调用对象时会自动调用构造【且只调用一次】

		—— 分类

			* 根据形参有无：无参构造(默认构造)和有参构造

			* 根据构造类型：普通构造和拷贝构造

		—— 调用：

			* 括号法

				基本语法：类名 变量名(数据) ;

				注意：使用默认构造时不要通过括号法【编译器会将其识别为函数的声明】

			* 显示法

				基本语法：类名 变量名 = 类名(数据) ;

				注意：只创建右侧的类名(数据)而没有左值，术语称之为【匿名对象】，即创即删

				忌：不要通过拷贝构造来创建匿名对象，形如【类名(变量名)】，其等价于【类名 变量名】，会引起重定义问题

			* 隐式转换法

				基本语法：类名 变量名 = 数据 ;【相当于编译器自动转换为显示法】

		—— 调用规则：

			* 如果用户已创建有参构造函数，编译器不再添加默认构造函数，但会提供拷贝构造函数

			* 如果用户已创建拷贝构造函数，编译器不再添加其他构造函数

	* 析构函数

		—— 基本语法：~类名(){}

		—— 作用：析构代码，释放堆区内存

		—— 注意：

			* 无返回值也不写void【这里的无返回值只是单纯的无需手写返回值】

			* 函数名必须与类名相同且在开头加一个“~”符号

			* 析构函数不可以有形参【因此没有重载功能】

			* 程序在销毁对象时会自动调用析构【且只调用一次】

4.拷贝构造函数

	* 基本语法：类名(const 类名 &形参名){}

	* 调用时机：

		—— 调用已创建完毕的对象来初始化一个新对象

		—— 以值传递的方式给函数传参

			理解：【值传递】都是通过穿入原变量的一个副本给函数，而创建副本的这一过程实则调用了拷贝构造函数

		—— 以值方式返回局部对象

			理解：【值返回】返回的是一个局部对象的副本，同样的，副本的创建过程调用了拷贝构造函数

	* 浅拷贝

		—— 概念：进行简单的赋值拷贝操作

		—— 缺点：造成堆区内存重复释放

	* 深拷贝
	
		—— 概念：在堆区重新申请空间，进行拷贝操作
	
		—— 理解：在创建拷贝构造函数时，将指针数据类型的属性通过new在堆区创建一个新的数据内存空间再指向其
