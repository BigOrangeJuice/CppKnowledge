C++_day04
2021/10/26

1.继承

	* 作用：减少代码重复

	* 基本语法：class 子类 : 继承方式 父类{}【子类成功继承父类,父类中对应继承方式的成员可供子类使用】

	* 子类也叫派生类，父类也叫基类

	* 方式【父类中的私有成员访问不到的原因：编译器隐藏掉了】

		―― 公共继承【public 父类】

			* 特点
			
				①父类中的公共/保护权限成员 到子类中仍然是公共/保护权限

				②父类中的私有权限成员，子类无法访问

		―― 保护继承【protected 父类】
		
			* 特点
			
				①父类中的公共/保护权限成员 到子类中是保护权限【若孙子类再继承子类，则在父类中原是公共/保护权限成员由于在子类中变为了保护权限，因此孙子类从子类中继承过来的成员仍是保护权限】

				②父类中的私有权限成员，子类无法访问

		―― 私有继承【private 父类】

			* 特点
			
				①父类中的公共/保护权限成员 到子类中是私有权限【若孙子类再继承子类，由于父类中原是公共/保护权限成员由于在子类中变为了私有权限，因此孙子类不再能访问这些私有成员】

				②父类中的私有权限成员，子类无法访问

	* 继承中的对象所占内存：自身的成员属性加上父类中所有非静态成员属性【包括私有成员】

	* 构造函数

		―― 调用：子类继承父类后，创建子类对象时，也会调用父类的构造函数

		―― 时刻：先调用父类构造，再调用子类构造【析构顺序相反】

	* 同名成员处理

		―― 前提：子类中有跟父类同名的成员【包括成员函数重载】

		―― 普通的对象.成员：调用的时子类中的对应成员

		―― 调用父类中的同名成员：再成员前面添加作用域【父类名::成员】

			* 基本语法：子类对象.父类名::成员 ;

	* 同名静态成员处理，同上

	* 多继承

		―― 基本语法：class 子类 :继承方式 父类1,继承方式 父类2 ...

		―― 注意
		
			* 多继承可能会引发父类中有同名成员出现，需要加作用域区分

			* C++开发中不建议多继承

		―― 菱形继承

			* 描述：两个派生类继承了同一个父类，而两个派生类又被一个子类所继承

			* 注意：派生类A继承了父类数据，派生类B继承了父类数据，当子类使用数据时就会出现二义性

				【很容易理解，上面提到了，多继承又有同名成员则需要通过添加作用域加以区分，但此时子类本身的数据却无法分清】

			* 解决：两个派生类在继承父类时，使用virtual关键字【即虚继承】

2.多态

	* 分类

		―― 静态多态：函数重载和运算符重载属于静态多态，复用函数名

		―― 动态多态：派生类和虚函数实现运行时多态【虚函数：virtual修饰的函数】

		―― 区别

			* 静态多态的函数地址早绑定【编译阶段确定函数地址】

			* 动态多态的函数地址晚绑定【运行阶段确定函数地址】
	
	* 作用：代码组织结构清晰化，加强可读性，有利于前期和后期的扩展及维护

	* 动态多态基本语法：派生类在重写父类中的函数后，当传入形参为父类而要调用派生类中的重写函数时，使用到多态，要将父类中的原版函数通过virtual修饰【简单地说，通过父类的指针或引用去创建或执行子类对象】

	* 动态多态满足条件

		―― 有继承条件

		―― 子类重写父类的虚函数

	* 纯虚函数【当类中有了纯虚函数，此类也成了抽象类】

		―― 基本语法：virtual 返回值类型 函数名(形参列表) = 0 ;

	* 抽象类

		―― 特点

			* 无法实例化对象

			* 子类必须重写抽象类中的纯虚函数，否则也属于抽象类

	* 虚析构与纯虚析构

		―― 使用前提：使用多态时，如果子类中有属性开辟到了堆区，那么父类指针在释放时无法调用到子类的析构函数

		―― 解决方式：将父类中的析构函数修改为虚析构函数或纯虚析构函数

		―― 共性

			* 可以通过父类指针释放子类对象

			* 都需要有具体的函数实现

		―― 区别：如果是纯虚析构，该类属于抽象类，无法实例化对象

		―― 基本语法

			* 虚析构：virtual ~父类名(){}

			* 纯虚析构：virtual ~父类名() = 0 ;
